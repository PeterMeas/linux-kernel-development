From ccd628f41a53e626270d90399e82e15e5c93888e Mon Sep 17 00:00:00 2001
From: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
Date: Fri, 10 Oct 2025 00:13:20 +0000
Subject: [PATCH v4 2/3] page_walk: patch2, add userspace test program &
 makefile

Signed-off-by: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
---
 peter_meas/page_walk/Makefile              |  11 ++
 peter_meas/page_walk/test_pagetable_walk.c | 151 +++++++++++++++++++++
 2 files changed, 162 insertions(+)
 create mode 100644 peter_meas/page_walk/Makefile
 create mode 100644 peter_meas/page_walk/test_pagetable_walk.c

diff --git a/peter_meas/page_walk/Makefile b/peter_meas/page_walk/Makefile
new file mode 100644
index 0000000..ef3264e
--- /dev/null
+++ b/peter_meas/page_walk/Makefile
@@ -0,0 +1,11 @@
+CC = gcc
+CFLAGS = -Wall -Wextra -O2
+all: test_pagetable_walk
+
+test_pagetable_walk: test_pagetable_walk.c
+	$(CC) $(CFLAGS) -o test_pagetable_walk test_pagetable_walk.c
+
+clean:
+	rm -f test_pagetable_walk
+
+.PHONY: all clean
diff --git a/peter_meas/page_walk/test_pagetable_walk.c b/peter_meas/page_walk/test_pagetable_walk.c
new file mode 100644
index 0000000..5131a61
--- /dev/null
+++ b/peter_meas/page_walk/test_pagetable_walk.c
@@ -0,0 +1,151 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/mman.h>
+
+#define __NR_riscv_pagetable_walk 257
+
+static int global_data = 123;
+static const char global_rodata[] = "Hello World";
+static void test_function(void) {
+	asm volatile ("" ::: "memory");
+}
+
+static long riscv_pagetable_walk(void *addr, unsigned long *output) {
+	return syscall(__NR_riscv_pagetable_walk, addr, output);
+}
+
+//what mode we use
+//
+static const char *satp_mode_name(unsigned long satp) {
+	unsigned long mode = satp >> 60;
+	switch (mode) {
+	case 0: return "Bare";
+	case 8: return "Sv39";
+	case 9: return "Sv48";
+	case 10: return "Sv57";
+	default: return "Unknown";
+	}
+//^ extract top4 bits determine mode
+
+
+
+}
+
+//print the flag bits from a PTE
+static void print_pte_flags(unsigned long pte) {
+	printf("Flags: V=%d R=%d W=%d X=%d U=%d G=%d A=%d D=%d\n",
+	!!(pte &(1 << 0)),	//valid
+
+	!!(pte &(1 << 1)),	//read
+	!!(pte &(1 << 2)),	//wr
+	!!(pte &(1 << 3)),	//exec
+	!!(pte &(1 << 4)),	//usr
+	!!(pte &(1 << 5)),	//glbl
+	!!(pte &(1 << 6)),	//accessed
+	!!(pte &(1 << 7)));	//dirty
+}
+
+static inline void touch_read(const void *p) {
+	(void)*(volatile const unsigned char *)p;
+
+}
+
+static inline void touch_write(const void *p) {
+
+	*(volatile unsigned char *)p = *(volatile unsigned char *)p;
+}
+
+static void test_address(const char *label, void * addr, int do_read, int do_write) {
+	unsigned long results[6] = {0};
+	//check memory
+	if (do_read) touch_read(addr);
+	if (do_write) touch_write(addr);
+
+	//syscall
+	long ret = riscv_pagetable_walk(addr, results);
+
+	//error check
+	if (ret < 0) {
+	printf("\n[%s] VA=%p - EROR: %s\n", label, addr, strerror(errno));
+	return;
+	}
+
+	//results
+	printf("\n[%s] VA = %p - Entries=%ld\n", label, addr, ret);
+
+	//sat
+	if (ret > 0) {
+	printf("SATP=0x%016lx MODE = %s\n",
+			results[0], satp_mode_name(results[0]));
+	}
+
+	//last entry
+	if (ret > 1 ) {
+	unsigned long leaf_pte = results[ret - 1];
+	unsigned long ppn = leaf_pte >> 10;
+	printf(" leaf PTE=0x%016lx PPN =0x%lx\n", leaf_pte, ppn);
+	print_pte_flags(leaf_pte);
+	}
+
+}
+
+
+
+int main(void) {
+
+
+
+	printf("=== RISC-V Page Table Walk Test ===\n");
+	printf("Syscall number: %d\n\n", __NR_riscv_pagetable_walk);
+
+	// Test 1: Code segment (RX)
+	printf("Testing code segment...\n");
+	test_address("Code (RX)", (void *)test_function, 1, 0);
+
+	// Test 2: Read-only data (R)
+	printf("\nTesting .rodata...\n");
+	test_address(".rodata (R)", (void *)global_rodata, 1, 0);
+
+	// Test 3: Data segment (RW)
+	printf("\nTesting .data...\n");
+	test_address(".data (RW)", &global_data, 1, 1);
+
+	// Test 4: Heap (RW)
+	printf("\nTesting heap...\n");
+	char *heap = malloc(4096);
+	if (heap) {
+		strcpy(heap, "heap test");
+		test_address("Heap (RW)", heap, 1, 1);
+		free(heap);
+	}
+
+	// Test 5: Stack (RW)
+	printf("\nTesting stack...\n");
+	volatile int stack_var = 42;
+	test_address("Stack (RW)", (void *)&stack_var, 1, 1);
+
+	// Test 6: Anonymous mmap - Read only
+	printf("\nTesting mmap (R)...\n");
+	void *anon_r = mmap(NULL, 4096, PROT_READ,
+	                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (anon_r != MAP_FAILED) {
+		test_address("mmap (R)", anon_r, 1, 0);
+		munmap(anon_r, 4096);
+	}
+
+	// Test 7: Anonymous mmap - Read+Execute
+	printf("\nTesting mmap (RX)...\n");
+	void *anon_rx = mmap(NULL, 4096, PROT_READ | PROT_EXEC,
+	                     MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (anon_rx != MAP_FAILED) {
+		test_address("mmap (RX)", anon_rx, 1, 0);
+		munmap(anon_rx, 4096);
+	}
+
+	printf("\n=== Test Complete ===\n");
+	return 0;
+}
-- 
2.51.0

