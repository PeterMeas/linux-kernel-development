From 448b4e1ffdf305d0f3381cba0218451994b9abe3 Mon Sep 17 00:00:00 2001
From: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
Date: Wed, 8 Oct 2025 02:14:46 +0000
Subject: [PATCH v4 1/3] page_walk: add kernel syscall implementation patch

Signed-off-by: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
---
 peter_meas/page_walk/syscall.patch | 137 +++++++++++++++++++++++++++++
 1 file changed, 137 insertions(+)
 create mode 100644 peter_meas/page_walk/syscall.patch

diff --git a/peter_meas/page_walk/syscall.patch b/peter_meas/page_walk/syscall.patch
new file mode 100644
index 0000000..c1b7ade
--- /dev/null
+++ b/peter_meas/page_walk/syscall.patch
@@ -0,0 +1,137 @@
+From b4edc8e58e48abe3f81053cede9151de76db0a54 Mon Sep 17 00:00:00 2001
+From: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
+Date: Wed, 8 Oct 2025 02:12:00 +0000
+Subject: [PATCH] pagewalk: added syscall.tbl, riscv pagetable c file, modified
+ syscall.h and Makefile
+
+Signed-off-by: Peter Meas <peter_meas@fall2025-uml.kdlp.underground.software>
+---
+ arch/riscv/include/asm/syscall.h     |  3 ++
+ arch/riscv/mm/Makefile               |  2 +-
+ arch/riscv/mm/riscv_pagetable_walk.c | 76 ++++++++++++++++++++++++++++
+ scripts/syscall.tbl                  |  2 +-
+ 4 files changed, 81 insertions(+), 2 deletions(-)
+ create mode 100644 arch/riscv/mm/riscv_pagetable_walk.c
+
+diff --git a/arch/riscv/include/asm/syscall.h b/arch/riscv/include/asm/syscall.h
+index 34313387f..b5e718bb5 100644
+--- a/arch/riscv/include/asm/syscall.h
++++ b/arch/riscv/include/asm/syscall.h
+@@ -121,4 +121,7 @@ asmlinkage long sys_riscv_flush_icache(uintptr_t, uintptr_t, uintptr_t);
+
+ asmlinkage long sys_riscv_hwprobe(struct riscv_hwprobe *, size_t, size_t,
+				  unsigned long *, unsigned int);
++
++asmlinkage long sys_riscv_pagetable_walk(void __user *vaddr,
++					unsigned long __user *output);
+ #endif	/* _ASM_RISCV_SYSCALL_H */
+diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
+index b916a68d3..7ebaf4709 100644
+--- a/arch/riscv/mm/Makefile
++++ b/arch/riscv/mm/Makefile
+@@ -13,7 +13,7 @@ endif
+ KCOV_INSTRUMENT_init.o := n
+
+ obj-y += init.o
+-obj-$(CONFIG_MMU) += extable.o fault.o pageattr.o pgtable.o tlbflush.o
++obj-$(CONFIG_MMU) += extable.o fault.o pageattr.o pgtable.o tlbflush.o riscv_pagetable_walk.o
+ obj-y += cacheflush.o
+ obj-y += context.o
+ obj-y += pmem.o
+diff --git a/arch/riscv/mm/riscv_pagetable_walk.c b/arch/riscv/mm/riscv_pagetable_walk.c
+new file mode 100644
+index 000000000..3ba925352
+--- /dev/null
++++ b/arch/riscv/mm/riscv_pagetable_walk.c
+@@ -0,0 +1,76 @@
++#include <linux/syscalls.h>
++#include <linux/uaccess.h>
++#include <asm/csr.h>
++#include <asm/page.h>
++#include <asm/pgtable.h>
++#include <linux/kernel.h>
++
++
++SYSCALL_DEFINE2(riscv_pagetable_walk,
++		void __user *, vaddr,
++		unsigned long __user *, output)
++{
++	unsigned long satp;		// hold SATP reg value; where is root page table?
++	unsigned long results[6];	// collect all values we find
++	int count = 0;
++
++	satp = csr_read(CSR_SATP);
++	results[count++] = satp;
++
++	unsigned long root_ppn = satp & 0xFFFFFFFFFFF;
++	unsigned long *root_table = (unsigned long *)phys_to_virt(root_ppn << 12); // Page x * 4096 bytes per page
++	//convert phys addr -> kernel vaddr
++	//extract VPN indices from v addr
++	unsigned long vaddr_ul = (unsigned long)vaddr;
++
++	unsigned long vpn4 = (vaddr_ul >> 48) & 0x1FF;
++	unsigned long vpn3 = (vaddr_ul >> 39) & 0x1FF;
++	unsigned long vpn2 = (vaddr_ul >> 30) & 0x1FF; //bits 38:30, 0x1FF mask for bottom 9 bits
++	unsigned long vpn1 = (vaddr_ul >> 21) & 0x1FF;	//bits 29:21
++	unsigned long vpn0 = (vaddr_ul >> 12) & 0x1FF;	//bits 20:12
++
++
++	unsigned long _pte4 = root_table[vpn4];
++	results[count++] = _pte4;
++	if (!(_pte4 & 0x1) || (_pte4 & 0xE))
++		goto copy_out;
++	unsigned long _ppn3 = (_pte4 >> 10) & 0xFFFFFFFFFF;
++	unsigned long *table3 = (unsigned long *)phys_to_virt(_ppn3 << 12);
++
++	unsigned long _pte3 = table3[vpn3];
++	results[count++] = _pte3;
++	if (!(_pte3 & 0x1)||(_pte3 & 0xE))
++		goto copy_out;
++
++
++
++
++	//index into root table
++	unsigned long _ppn2 = (_pte3 >> 10) & 0xFFFFFFFFFF;
++	unsigned long *table2 = (unsigned long *)phys_to_virt(_ppn2 << 12);
++	unsigned long _pte2 = table2[vpn2];
++//	unsigned long _pte1 = root_table[vpn1];
++//	unsigned long _pte0 = root_table[vpn0];
++
++	results[count++] = _pte2;
++	if (!(_pte2 & 0x1) || (_pte2 & 0xE))
++		goto copy_out;
++
++
++	unsigned long _ppn1 = (_pte2 >> 10) & 0xFFFFFFFFFFF;
++	unsigned long *table1 = (unsigned long *)phys_to_virt(_ppn1 << 12); // converts page # to byte addr
++	unsigned long _pte1 = table1[vpn1];
++	results[count++] = _pte1;
++	if (!(_pte1 & 0x1) || (_pte1 & 0xE))
++		goto copy_out;
++
++	unsigned long _ppn0 = (_pte1 >> 10) & 0xFFFFFFFFFFF;
++	unsigned long *table0 = (unsigned long *)phys_to_virt(_ppn0 << 12);
++	unsigned long _pte0 = table0[vpn0];
++	results[count++] = _pte0;
++
++copy_out:
++	if (copy_to_user(output, results, count * sizeof(unsigned long)))
++		return -EFAULT;
++	return count;
++}
+diff --git a/scripts/syscall.tbl b/scripts/syscall.tbl
+index 580b4e246..967a69431 100644
+--- a/scripts/syscall.tbl
++++ b/scripts/syscall.tbl
+@@ -301,7 +301,7 @@
+ 244	nios2	cacheflush			sys_cacheflush
+
+ 244	or1k	or1k_atomic			sys_or1k_atomic
+-
++257	riscv	riscv_pagetable_walk		sys_riscv_pagetable_walk
+ 258	riscv	riscv_hwprobe			sys_riscv_hwprobe
+ 259	riscv	riscv_flush_icache		sys_riscv_flush_icache
+
+--
+2.51.0
-- 
2.51.0

